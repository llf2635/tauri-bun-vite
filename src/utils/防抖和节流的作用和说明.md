# 防抖（Debounce）和节流（Throttle）详解

防抖和节流是两种常用的性能优化技术，主要用于控制函数执行的频率，特别是在处理高频触发事件时。

## 防抖（Debounce）

### 定义
防抖是指触发高频事件后，函数在指定时间间隔内只执行最后一次。如果在等待时间内再次触发事件，则重新计时。

### 工作原理
1. 事件触发后不立即执行函数
2. 设置一个定时器延迟执行
3. 如果在延迟期间再次触发事件，则取消之前的定时器并重新设置
4. 只有在事件停止触发超过指定时间后，函数才会执行

### 类比解释
就像电梯关门：当有人进出时，电梯不会立即关门，而是等待一段时间（比如10秒），如果在这10秒内又有人进来，就重新等待10秒，直到没有人进出才真正关门。

### 代码实现

```javascript
function debounce(func, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer); // 清除之前的定时器
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
```

### 应用场景
1. 搜索框输入联想（等待用户停止输入后再发送请求）
2. 窗口大小调整事件（等待调整结束后再计算布局）
3. 表单验证（用户停止输入后再验证）
4. 防止按钮重复点击

## 节流（Throttle）

### 定义
节流是指在高频触发事件时，函数在指定时间间隔内只执行一次，稀释函数的执行频率。

### 工作原理
1. 事件触发后立即执行函数（或设置定时器延迟执行）
2. 设置一个锁定期
3. 在锁定期内再次触发事件会被忽略
4. 锁定期结束后才能再次触发执行

### 类比解释
就像机枪射击：无论你扣住扳机多久，机枪只会以固定的频率发射子弹（比如每秒10发），而不是连续不断地发射。

### 代码实现

```javascript
function throttle(func, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      func.apply(this, args);
      lastTime = now;
    }
  };
}
```

### 定时器版本（延迟执行）

```javascript
function throttle(func, delay) {
  let timer = null;
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        func.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}
```

### 应用场景
1. 页面滚动事件（比如无限滚动加载）
2. 鼠标移动事件（如拖拽元素）
3. 游戏中的键盘/鼠标输入处理
4. 高频点击的提交按钮

## 防抖与节流的对比

| 特性        | 防抖（Debounce）                     | 节流（Throttle）                     |
|------------|-------------------------------------|-------------------------------------|
| **执行时机** | 事件停止触发后执行                   | 固定时间间隔执行                     |
| **重置机制** | 每次触发都会重置计时器               | 固定时间间隔内只执行一次              |
| **适用场景** | 关注最终状态（如搜索输入完成）        | 关注过程状态（如滚动位置）            |
| **首次触发** | 默认不立即执行（可配置）             | 可立即执行或延迟执行                 |
| **执行次数** | 只执行最后一次                       | 均匀分布执行                         |

## 实际应用示例

### 搜索框防抖

```javascript
const searchInput = document.getElementById('search');
const debouncedSearch = debounce(search, 500);

searchInput.addEventListener('input', debouncedSearch);

function search() {
  // 发送搜索请求
  console.log('搜索:', searchInput.value);
}
```

### 窗口滚动节流

```javascript
const throttledScroll = throttle(handleScroll, 200);

window.addEventListener('scroll', throttledScroll);

function handleScroll() {
  // 处理滚动逻辑
  console.log('当前滚动位置:', window.scrollY);
}
```

## 高级版本实现（带立即执行选项）

### 防抖高级版

```javascript
function debounce(func, delay, immediate = false) {
  let timer = null;
  return function(...args) {
    const context = this;
    const later = () => {
      timer = null;
      if (!immediate) func.apply(context, args);
    };
    
    const callNow = immediate && !timer;
    clearTimeout(timer);
    timer = setTimeout(later, delay);
    
    if (callNow) func.apply(context, args);
  };
}
```

### 节流高级版

```javascript
function throttle(func, delay, options = {}) {
  let lastTime = 0;
  let timer = null;
  const { leading = true, trailing = true } = options;
  
  return function(...args) {
    const context = this;
    const now = Date.now();
    
    if (!lastTime && !leading) lastTime = now;
    
    const remaining = delay - (now - lastTime);
    
    if (remaining <= 0 || remaining > delay) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      lastTime = now;
      func.apply(context, args);
    } else if (trailing && !timer) {
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
```

## 为什么需要防抖和节流？

1. **性能优化**：减少不必要的函数执行，特别是计算量大或涉及DOM操作的函数
2. **网络请求控制**：避免短时间内发送大量请求（如搜索建议）
3. **提升用户体验**：防止界面卡顿或闪烁
4. **资源节约**：减少CPU、内存和网络资源的消耗
5. **防止重复提交**：避免用户重复点击导致的多次提交

## 现代前端框架中的使用

### Vue 中使用

```javascript
import { debounce, throttle } from 'lodash-es';

export default {
  methods: {
    // 防抖方法
    search: debounce(function() {
      // 搜索逻辑
    }, 500),
    
    // 节流方法
    handleScroll: throttle(function() {
      // 滚动处理
    }, 200)
  }
}
```

### React 中使用

```javascript
import { useCallback } from 'react';
import { debounce, throttle } from 'lodash-es';

function MyComponent() {
  // 防抖回调
  const debouncedSearch = useCallback(
    debounce((query) => {
      // 搜索逻辑
    }, 500),
    []
  );

  // 节流回调
  const throttledScroll = useCallback(
    throttle(() => {
      // 滚动处理
    }, 200),
    []
  );

  return (
    // ...
  );
}
```

## 总结

防抖和节流是前端开发中必不可少的性能优化技术，理解它们的区别和适用场景对于编写高效的前端代码至关重要。记住：

- **防抖**：适合"最终状态"场景，如搜索输入完成
- **节流**：适合"过程状态"场景，如滚动位置跟踪

在实际开发中，可以根据具体需求选择合适的实现方式，或者使用 Lodash 等库提供的经过充分测试的 `_.debounce` 和 `_.throttle` 函数。