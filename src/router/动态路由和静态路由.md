# 动态路由与静态路由详解

## 一、静态路由 vs 动态路由

### 静态路由
**定义**：在应用初始化时就定义好的固定路由配置。

**特点**：
- 在项目构建时确定
- 所有用户访问的路由相同
- 配置在路由配置文件中写死
- 适用于不需要权限控制的公开页面

**示例**：
```typescript
const staticRoutes = [
  {
    path: '/home',
    component: Home
  },
  {
    path: '/about',
    component: About
  }
]
```

### 动态路由
**定义**：根据应用运行时的条件（如用户权限）动态添加的路由。

**特点**：
- 在运行时动态添加/删除
- 不同用户可能看到不同的路由
- 通常来自API接口或权限系统
- 适用于需要权限控制的系统

## 二、动态路由的核心作用

1. **权限控制**：根据用户角色/权限动态生成可访问路由
2. **模块化**：插件化系统中动态注册模块路由
3. **灵活性**：不同环境/条件下显示不同路由
4. **按需加载**：减少初始包体积，提高性能

## 三、动态路由实现方式

### 1. 基础实现示例

```typescript
// 静态路由(所有用户都能访问)
const constantRoutes = [
  {
    path: '/login',
    component: () => import('@/views/login.vue')
  }
]

// 动态路由(需要权限)
const asyncRoutes = [
  {
    path: '/admin',
    component: () => import('@/views/admin.vue'),
    meta: { roles: ['admin'] }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes
})

// 登录后动态添加路由
export function addRoutes(userRoles: string[]) {
  const allowedRoutes = asyncRoutes.filter(route => {
    return !route.meta?.roles || userRoles.some(role => route.meta.roles.includes(role))
  })
  
  allowedRoutes.forEach(route => {
    router.addRoute(route)
  })
}
```

### 2. 完整权限路由方案

**步骤1**：定义路由类型 (`types/router.ts`)

```typescript
export interface AppRouteRecordRaw {
  path: string
  name?: string
  component?: Component | string
  meta?: {
    title?: string
    roles?: string[]
    icon?: string
    hidden?: boolean
  }
  children?: AppRouteRecordRaw[]
}
```

**步骤2**：API获取动态路由

```typescript
// api/routes.ts
export const getRoutes = async (): Promise<AppRouteRecordRaw[]> => {
  return await request.get('/api/routes')
}
```

**步骤3**：路由转换器（将API数据转为路由格式）

```typescript
// utils/routeConverter.ts
export const convertRoutes = (apiRoutes: any[]): AppRouteRecordRaw[] => {
  return apiRoutes.map(route => ({
    path: route.path,
    name: route.name,
    component: () => import(`@/views/${route.component}.vue`),
    meta: {
      title: route.title,
      roles: route.roles,
      icon: route.icon
    },
    children: route.children ? convertRoutes(route.children) : undefined
  }))
}
```

**步骤4**：动态路由管理

```typescript
// store/permission.ts (Pinia示例)
export const usePermissionStore = defineStore('permission', {
  state: () => ({
    routes: [] as AppRouteRecordRaw[],
    addRoutes: [] as AppRouteRecordRaw[]
  }),
  
  actions: {
    async generateRoutes(roles: string[]) {
      // 1. 获取API路由
      const apiRoutes = await getRoutes()
      
      // 2. 过滤有权限的路由
      const accessedRoutes = apiRoutes.filter(route => {
        return !route.meta?.roles || roles.some(role => route.meta.roles.includes(role))
      })
      
      // 3. 转换路由组件
      this.addRoutes = convertRoutes(accessedRoutes)
      
      // 4. 添加到路由器
      this.addRoutes.forEach(route => {
        router.addRoute(route)
      })
      
      this.routes = constantRoutes.concat(this.addRoutes)
    }
  }
})
```

## 四、动态路由使用场景

### 场景1：权限管理系统

```typescript
// 登录成功后
const userStore = useUserStore()
const permissionStore = usePermissionStore()

login().then(data => {
  userStore.setUser(data.user)
  permissionStore.generateRoutes(data.user.roles)
})
```

### 场景2：多租户系统

```typescript
// 根据租户类型加载不同路由
const loadTenantRoutes = async (tenantType: string) => {
  const routes = await getTenantRoutes(tenantType)
  routes.forEach(route => router.addRoute(route))
}
```

### 场景3：插件系统

```typescript
// 插件注册时添加路由
const registerPlugin = (plugin: Plugin) => {
  plugin.routes?.forEach(route => {
    router.addRoute('PluginLayout', route)
  })
}
```

## 五、动态路由最佳实践

1. **路由分层**：
    - 基础路由（404/登录页）静态定义
    - 权限路由动态加载

2. **路由缓存**：
   ```typescript
   // 缓存动态路由避免重复添加
   let dynamicRoutesAdded = false

   function addDynamicRoutes() {
     if (dynamicRoutesAdded) return
     // 添加路由逻辑...
     dynamicRoutesAdded = true
   }
   ```

3. **路由重置**：
   ```typescript
   export function resetRouter() {
     router.getRoutes().forEach(route => {
       if (route.name && !constantRouteNames.includes(route.name)) {
         router.removeRoute(route.name)
       }
     })
   }
   ```

4. **路由加载状态**：
   ```vue
   <template>
     <router-view v-if="isRouterReady" />
     <Loading v-else />
   </template>

   <script setup>
   const isRouterReady = ref(false)

   onMounted(async () => {
     await loadDynamicRoutes()
     isRouterReady.value = true
   })
   </script>
   ```

## 六、常见问题解决方案

**问题1**：动态路由刷新后丢失  
**方案**：在路由守卫中重新添加
```typescript
router.beforeEach(async (to) => {
  if (!permissionStore.routes.length && !isWhiteList(to)) {
    await permissionStore.generateRoutes()
    return to.fullPath // 重定向到原路由
  }
})
```

**问题2**：路由重复添加  
**方案**：使用标志位或路由名称检查
```typescript
if (!router.hasRoute(route.name!)) {
  router.addRoute(route)
}
```

**问题3**：动态路由缓存  
**方案**：使用`keep-alive` + 组件name
```vue
<router-view v-slot="{ Component }">
  <keep-alive :include="cachedViews">
    <component :is="Component" :key="$route.fullPath" />
  </keep-alive>
</router-view>
```

动态路由是现代前端权限系统的核心，合理使用可以构建出既安全又灵活的应用架构。实际项目中应根据业务需求选择合适的实现方案。